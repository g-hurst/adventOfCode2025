use std::{fs, path::Path};

fn main() {
    let mut entries: Vec<(u32, String)> = fs::read_dir("src/days")
        .expect("Failed to read src/days")
        .filter_map(|entry| {
            let entry = entry.ok()?;
            let meta = entry.metadata().ok()?;
            if !meta.is_file() {
                return None;
            }
            let name = entry.file_name();
            let name = name.to_str()?;

            if !name.starts_with("day") || !name.ends_with(".rs") {
                return None;
            }

            let stem = &name[..name.len() - 3]; // strip .rs
            let num_str = &stem[3..];
            let num: u32 = num_str.parse().ok()?;

            Some((num, stem.to_string()))
        })
        .collect();

    entries.sort_by_key(|(n, _)| *n);

    let mut code = String::new();

    code.push_str("// AUTO-GENERATED by build.rs. Do not edit manually.\n");

    // Declare modules
    for (_, mod_name) in &entries {
        code.push_str(&format!("pub mod {};\n", mod_name));
    }

    // Dispatcher
    code.push_str("\n");
    code.push_str("pub fn run_day(day: u32, part: u8, use_example: bool) -> Option<String> {\n");
    code.push_str("    match (day, part) {\n");
    for (num, mod_name) in &entries {
        code.push_str(&format!(
            "        ({}, 1) => Some({}::part1(use_example)),\n",
            num, mod_name
        ));
        code.push_str(&format!(
            "        ({}, 2) => Some({}::part2(use_example)),\n",
            num, mod_name
        ));
    }
    code.push_str("        _ => None,\n");
    code.push_str("    }\n");
    code.push_str("}\n");

    let out_path = Path::new("src/days/mod.rs");
    fs::write(&out_path, code).expect("Failed to write src/days/mod.rs");
}
